{"version":3,"file":"address.js","sourceRoot":"","sources":["../../src/wallet/address.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ADDRESS_BYTES_LEN,\n  ADDRESS_BYTES_PREFIX,\n  ED_BASE,\n  EMIT_ADDR_BS_H0,\n  EMIT_ADDR_BS_H1,\n} from \"./serial\";\nimport { blake2bHash, toScalar } from \"./sign\";\nconst bs58 = require(\"bs58\");\n\nexport function getPublicKeyBs58(privateKey: Buffer): string {\n  const pk = privateKey.slice(0, 32);\n\n  const pb = ED_BASE.multiply(toScalar(pk));\n  // const pubKey = Buffer.from(pb.toRistrettoBytes());\n  const pubKey = pb.toRawBytes();\n\n  const prefix = Buffer.from(ADDRESS_BYTES_PREFIX, \"hex\");\n  const h0 = blake2bHash(EMIT_ADDR_BS_H0, Buffer.concat([prefix, pubKey]));\n  const h0_r = Buffer.alloc(32, 0);\n  h0_r.fill(h0, 0, h0.length > 32 ? 32 : h0.length);\n\n  const h1 = blake2bHash(EMIT_ADDR_BS_H1, Buffer.concat([h0_r, pubKey]));\n  const h1_r = Buffer.alloc(32, 0);\n  h1_r.fill(h1, 0, h1.length > 32 ? 32 : h1.length);\n\n  const r = Buffer.alloc(ADDRESS_BYTES_LEN, 0);\n  const w = Buffer.concat([prefix, pubKey, h1_r.slice(0, 3)]);\n  r.fill(w, 0, w.length > ADDRESS_BYTES_LEN ? ADDRESS_BYTES_LEN : w.length);\n  return bs58.encode(r);\n}\n\nexport function getPublicKey(privateKey: Buffer): Buffer {\n  const sk = toScalar(privateKey.slice(0, 32));\n  const pubKey = ED_BASE.multiply(sk).toRawBytes();\n  const buf = Buffer.alloc(32, 0);\n  buf.fill(pubKey, 0, pubKey.length);\n  return buf;\n}\n\nexport function fromAddressBytes(addr: string): Buffer {\n  const data: Buffer = bs58.decode(addr);\n  if (data.length != ADDRESS_BYTES_LEN) {\n    throw new Error(\"the address bytes len != 36\");\n  }\n  if (data[0] != 0x1e) {\n    throw new Error(\"the address prefix is invalid\");\n  }\n  const h0 = blake2bHash(EMIT_ADDR_BS_H0, data.slice(0, 33));\n  const h0_r = h0.slice(0, 32);\n  const h1 = blake2bHash(EMIT_ADDR_BS_H1, Buffer.concat([h0_r, data.slice(1, 33)]));\n  const h1_r = h1.slice(0, 32);\n\n  const left = Buffer.from(data.slice(33));\n  const right = h1_r.slice(0,3);\n  console.log(left,right);\n  if (left.toString('hex') != right.toString('hex')) {\n    throw new Error(\"the address bytes sum-check failed\");\n  }\n  return data.slice(1, 33);\n}\n"]}