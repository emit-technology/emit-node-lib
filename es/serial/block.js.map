{"version":3,"file":"block.js","sourceRoot":"","sources":["../../src/serial/block.ts"],"names":[],"mappings":"AACA,OAAO,cAAc,MAAM,aAAa,CAAC;AACzC,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAE5C,OAAO,gBAAgB,MAAM,cAAc,CAAC;AAC5C,MAAM,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;AAE5B,MAAM,WAAW;IAEf,YAAY,IAAW;QAIvB,WAAM,GAAG,GAAW,EAAE;YACpB,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC;YACxB,MAAM,MAAM,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;YAC9D,MAAM,OAAO,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;YACrE,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC,UAAU;YACvE,MAAM,UAAU,GAAG,IAAI,cAAc,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE,CAAC;YAChE,MAAM,YAAY,GAAG,IAAI,gBAAgB,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,MAAM,EAAE,CAAC;YACrE,MAAM,MAAM,GAAkB;gBAC5B,MAAM;gBACN,OAAO;gBACP,aAAa;gBACb,UAAU;gBACV,YAAY;aACb,CAAC;YACF,IAAI,KAAK,CAAC,IAAI,EAAE;gBACd,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,aAAa,EAAE;oBACrC,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;iBAC7C;gBACD,MAAM,CAAC,IAAI,CACT,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,CACvD,MAAM,EACN,IAAI,EACJ,CAAC,CACF,CACF,CAAC;gBACF,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;aAC7C;iBAAM;gBACL,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;aAC1C;YACD,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAChC,OAAO,CAAC,CAAC;QACX,CAAC,CAAC;QAlCA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;CAkCF;AAED,eAAe,WAAW,CAAC","sourcesContent":["import { Block } from \"../types\";\nimport DataSetsSerial from \"./data_sets\";\nimport { BYTES_MAX_LEN } from \"./constants\";\nimport SerialTrait from \"./serial_trait\";\nimport FactorSetsSerial from \"./factor_set\";\nconst BN = require(\"bn.js\");\n\nclass BlockSerial implements SerialTrait {\n  data: Block;\n  constructor(data: Block) {\n    this.data = data;\n  }\n\n  serial = (): Buffer => {\n    const block = this.data;\n    const numBuf = new BN(block.num).toArrayLike(Buffer, \"le\", 8);\n    const timeBuf = new BN(block.timestamp).toArrayLike(Buffer, \"le\", 8);\n    const parentHashBuf = Buffer.from(block.parent_hash, \"hex\"); //32 bytes\n    const dataSetBuf = new DataSetsSerial(block.data_sets).serial();\n    const factorSetBuf = new FactorSetsSerial(block.factor_set).serial();\n    const bufArr: Array<Buffer> = [\n      numBuf,\n      timeBuf,\n      parentHashBuf,\n      dataSetBuf,\n      factorSetBuf,\n    ];\n    if (block.data) {\n      if (block.data.length > BYTES_MAX_LEN) {\n        throw new Error(\"Bytes content is too big\");\n      }\n      bufArr.push(\n        new BN(Buffer.from(block.data, \"hex\").length).toArrayLike(\n          Buffer,\n          \"le\",\n          4\n        )\n      );\n      bufArr.push(Buffer.from(block.data, \"hex\"));\n    } else {\n      bufArr.push(Buffer.alloc(4, 0).fill(\"\"));\n    }\n    const r = Buffer.concat(bufArr);\n    return r;\n  };\n}\n\nexport default BlockSerial;\n"]}