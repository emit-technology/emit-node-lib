// Generated by dts-bundle-generator v5.8.0

/// <reference types="node" />

import * as ed from '@noble/ed25519';
import { RistrettoPoint } from '@noble/ed25519';

export interface AccountModel {
	accountId?: string;
	name?: string;
	passwordHint?: string;
	avatar?: string;
	addresses?: {
		[chainType: number]: string;
	};
	key?: string;
	wallets?: {
		[chainType: number]: any;
	};
	backedUp?: boolean;
	timestamp?: number;
	password?: string;
}
export declare enum CreateType {
	Mnemonic = 0,
	PrivateKey = 1
}
export declare enum ChainType {
	_ = 0,
	SERO = 1,
	ETH = 2,
	TRON = 3,
	BSC = 4,
	EMIT = 5
}
export interface FactorSet {
	settles: Array<Settle>;
	outs: Array<Out>;
}
export interface Factor {
	category: Category;
	value: string;
}
export interface Category {
	supplier: string;
	symbol: string;
	id: string;
}
export interface Out {
	target: string;
	factor: Factor;
	data: string;
}
export interface DataSet {
	name: string;
	data: string;
	old: string;
}
export interface PrepareBlock {
	address: string;
	blk: Block;
}
export interface BlockRef {
	num: number;
	hash: string;
}
export interface Block {
	num: number;
	timestamp: number;
	parent_hash: string;
	data_sets: Array<DataSet>;
	factor_set: FactorSet;
	data?: string;
}
export interface Settle {
	from: string;
	num: number;
	index: number;
	factor: Factor;
}
export interface OutFactor {
	factor: Factor;
	timestamp: number;
}
export interface BlockWrapped {
	hash: string;
	block: Block;
}
export declare const getDefaultHash: () => string;
export interface Signature {
	s: bigint;
	R: RistrettoPoint;
}
export interface SignEL {
	r: string;
	s: string;
	v: string;
}
export interface ConfirmedAccount {
	addr: string;
	blk_ref: BlockRef;
}
export interface SettleResp {
	factor: OutFactor;
	from_index_key: FromIndexKey;
	settled: boolean;
}
export interface FromIndexKey {
	from: string;
	num: number;
	index: number;
}
export interface Sign {
	r: string;
	s: string;
}
export interface MsgWithSign<T> {
	data: T;
	sign: SignWithAddress;
}
export interface SignWithAddress {
	addr: string;
	sign: Sign;
}
export declare const ecsign: (m: string, privateKey: Buffer) => SignEL;
export declare const ecrecover: (signEL: SignEL, h: string) => string;
export declare const verify: (m: Buffer, sig: Signature, publicKey: Buffer) => boolean;
export declare const personalSign: (privateKey: Buffer, msgParams: string) => SignEL;
export declare const hashPersonalMessage: (message: Buffer) => Buffer;
export declare const recoverPersonalSignature: (sig: SignEL, msgHex: string) => string;
export declare const BYTES_MAX_LEN: number;
export declare const VEC_T_MAX_LEN: number;
export declare const ADDRESS_BYTES_LEN = 36;
export declare const ADDRESS_BYTES_PREFIX = "1e";
export declare const EMIT_ADDR_BS_H0 = "EM_ADDR_BS_H0";
export declare const EMIT_ADDR_BS_H1 = "EM_ADDR_BS_H1";
export declare const ED_BASE: ed.RistrettoPoint;
export declare function getPublicKeyBs58(privateKey: Buffer): string;
export declare function getPublicKey(privateKey: Buffer): Buffer;
export declare function fromAddressBytes(addr: string): Buffer;
export declare function checkSumAddress(addr: string): boolean;
export declare function blake2bHash(personal: string, data: Buffer): Buffer;
export declare function prepareBlockToHash(prepareBlock: PrepareBlock): string;
export declare function blockToHash(block: Block): string;
export declare function toScalar(bytes: Uint8Array): bigint;
export declare function bytesToNumberLE(uint8a: Uint8Array): bigint;
export declare function mod(a: bigint, b?: bigint): bigint;
export declare function signPrepareBlock(h: string, privateKey: Buffer): Sign;

export as namespace emitLib;

export {};
