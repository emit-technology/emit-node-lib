{"version":3,"file":"data_sets.js","sourceRoot":"","sources":["../../src/serial/data_sets.ts"],"names":[],"mappings":";;AACA,2CAA0C;AAG1C,MAAM,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;AAE5B,MAAM,cAAc;IAGhB,YAAY,IAAoB;QAIhC,WAAM,GAAG,GAAW,EAAE;YAClB,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,yBAAa,EAAE;gBAC/C,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;aACrC;YACD,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;YAC7B,MAAM,MAAM,GAAG,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;YACxD,MAAM,MAAM,GAAkB,CAAC,MAAM,CAAC,CAAC;YACvC,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE;gBACrB,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC3C,MAAM,UAAU,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA;gBACzF,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;gBAE1C,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACrB,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACxB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAErB,IAAG,CAAC,CAAC,GAAG,EAAC;oBACL,MAAM,UAAU,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA;oBACzD,MAAM,SAAS,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,CAClE,MAAM,EACN,IAAI,EACJ,CAAC,CACJ,CAAA;oBACD,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;oBAExC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;oBACxB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBACvB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBACvB;qBAAI;oBACD,MAAM,UAAU,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA;oBACzD,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;iBAC3B;aACJ;YACD,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACjC,CAAC,CAAC;QArCE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACrB,CAAC;CAqCJ;AAED,kBAAe,cAAc,CAAC","sourcesContent":["import {DataSet} from \"../types\";\nimport {VEC_T_MAX_LEN} from \"./constants\";\nimport SerialTrait from \"./serial_trait\";\n\nconst BN = require(\"bn.js\");\n\nclass DataSetsSerial implements SerialTrait {\n    data: Array<DataSet>;\n\n    constructor(data: Array<DataSet>) {\n        this.data = data;\n    }\n\n    serial = (): Buffer => {\n        if (this.data && this.data.length > VEC_T_MAX_LEN) {\n            throw new Error(\"INVALID_FORMAT\");\n        }\n        const len = this.data.length;\n        const lenBuf = new BN(len).toArrayLike(Buffer, \"le\", 4);\n        const bufArr: Array<Buffer> = [lenBuf];\n        for (let d of this.data) {\n            const nameBuf = Buffer.from(d.name, \"hex\");\n            const dataLenBuf = new BN(Buffer.from(d.data, \"hex\").length).toArrayLike(Buffer, \"le\", 4)\n            const dataBuf = Buffer.from(d.data, \"hex\")\n\n            bufArr.push(nameBuf);\n            bufArr.push(dataLenBuf);\n            bufArr.push(dataBuf);\n\n            if(d.old){\n                const oldStation = new BN(1).toArrayLike(Buffer, \"le\", 1)\n                const oldLenBuf = new BN(Buffer.from(d.old, \"hex\").length).toArrayLike(\n                    Buffer,\n                    \"le\",\n                    4\n                )\n                const oldBuf = Buffer.from(d.old, \"hex\")\n\n                bufArr.push(oldStation);\n                bufArr.push(oldLenBuf);\n                bufArr.push(oldBuf);\n            }else{\n                const oldStation = new BN(0).toArrayLike(Buffer, \"le\", 1)\n                bufArr.push(oldStation);\n            }\n        }\n        return Buffer.concat(bufArr);\n    };\n}\n\nexport default DataSetsSerial;\n"]}