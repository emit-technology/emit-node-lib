{"version":3,"file":"sign.js","sourceRoot":"","sources":["../../src/crypto/sign.ts"],"names":[],"mappings":";;;;AACA,kCAAgE;AAChE,wCAA8D;AAC9D,sCAAkC;AAClC,2DAAqC;AACrC,iEAA2C;AAC3C,qDAAyC;AAGzC,MAAM,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;AAErB,MAAM,MAAM,GAAG,CAAC,CAAQ,EAAE,UAAkB,EAAS,EAAE;IAC3D,MAAM,IAAI,GAAG,IAAA,uBAAgB,EAAC,CAAC,EAAC,UAAU,CAAC,CAAA;IAC3C,OAAO;QACJ,CAAC,EAAE,IAAI,CAAC,CAAC;QACT,CAAC,EAAE,IAAI,CAAC,CAAC;QACT,CAAC,EAAE,IAAA,0BAAgB,EAAC,UAAU,CAAC;KACjC,CAAA;AACJ,CAAC,CAAA;AAPY,QAAA,MAAM,UAOlB;AAEM,MAAM,SAAS,GAAG,CAAC,MAAa,EAAC,CAAQ,EAAS,EAAE;IACxD,MAAM,CAAC,GAAG,IAAA,eAAQ,EAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAC,KAAK,CAAC,CAAC,CAAC;IAChD,MAAM,CAAC,GAAG,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC9C,MAAM,GAAG,GAAa;QACnB,CAAC,EAAC,CAAC;QACH,CAAC,EAAC,CAAC;KACL,CAAA;IACD,MAAM,EAAE,GAAG,IAAA,0BAAgB,EAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IACtC,MAAM,CAAC,GAAG,IAAA,0BAAQ,EAAC,CAAC,CAAC,CAAC;IACtB,IAAG,IAAA,cAAM,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,CAAC,EAAC;QACjB,OAAO,MAAM,CAAC,CAAC,CAAA;KACjB;IACD,OAAO,aAAa,CAAA;AACvB,CAAC,CAAA;AAbY,QAAA,SAAS,aAarB;AAGM,MAAM,MAAM,GAAG,CAAC,CAAQ,EAAC,GAAa,EAAC,SAAgB,EAAC,EAAE;IAC9D,MAAM,IAAI,GAAG,gBAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACrC,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAChD,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;IACtE,IAAI,IAAI,GAAG,IAAA,kBAAW,EAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IAC/C,MAAM,CAAC,GAAG,IAAA,eAAQ,EAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACtC,MAAM,KAAK,GAAG,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAG,CAAA,sEAAsE;IAC9I,OAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC9B,CAAC,CAAA;AARY,QAAA,MAAM,UAQlB;AAGM,MAAM,YAAY,GAAG,CAAC,UAAkB,EAAE,SAAgB,EAAS,EAAE;IACzE,MAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;IAC3C,MAAM,OAAO,GAAG,IAAA,2BAAmB,EAAC,MAAM,CAAC,CAAC;IAC5C,MAAM,GAAG,GAAG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACpC,OAAO,IAAA,cAAM,EAAC,GAAG,EAAC,UAAU,CAAC,CAAA;AAChC,CAAC,CAAA;AALY,QAAA,YAAY,gBAKxB;AACM,MAAM,mBAAmB,GAAG,UAAU,OAAe;IACzD,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,+BAA+B,OAAO,CAAC,MAAM,EAAE,EAAE,OAAO,CAAC,CAAA;IACpF,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAA;AAC1D,CAAC,CAAA;AAHY,QAAA,mBAAmB,uBAG/B;AAGM,MAAM,wBAAwB,GAAG,CAAC,GAAU,EAAC,MAAa,EAAU,EAAE;IAC1E,OAAO,IAAA,iBAAS,EAAC,GAAG,EAAC,MAAM,CAAC,CAAA;AAC/B,CAAC,CAAA;AAFY,QAAA,wBAAwB,4BAEpC","sourcesContent":["import {Signature, SignEL} from \"../types\";\nimport {blake2bHash, signPrepareBlock, toScalar} from \"../sign\";\nimport {fromAddressBytes, getPublicKeyBs58} from \"../address\";\nimport {ED_BASE} from \"../serial\";\nimport * as ed from \"@noble/ed25519\";\nimport * as ethUtil from 'ethereumjs-util';\nimport {toBuffer} from \"ethereumjs-util\";\n\n\nconst BN = require('bn.js');\n\nexport const ecsign = (m:string, privateKey: Buffer):SignEL =>{\n   const sign = signPrepareBlock(m,privateKey)\n   return {\n      r: sign.r,\n      s: sign.s,\n      v: getPublicKeyBs58(privateKey)\n   }\n}\n\nexport const ecrecover = (signEL:SignEL,h:string):string => {\n   const s = toScalar(Buffer.from(signEL.s,\"hex\"));\n   const R = ed.RistrettoPoint.fromHex(signEL.r);\n   const sig:Signature = {\n      s:s,\n      R:R\n   }\n   const pb = fromAddressBytes(signEL.v);\n   const m = toBuffer(h);\n   if(verify(m,sig,pb)){\n      return signEL.v\n   }\n   return \"Invalid sig\"\n}\n\n\nexport const verify = (m:Buffer,sig:Signature,publicKey:Buffer)=>{\n   const left = ED_BASE.multiply(sig.s);\n   const pkHex = new BN(publicKey).toString(\"hex\");\n   const concatBuf = Buffer.concat([m, Buffer.from(sig.R.toRawBytes())]);\n   let hash = blake2bHash(\"EMIT-SIGN\", concatBuf);\n   const e = toScalar(hash.slice(0, 32));\n   const right = ed.RistrettoPoint.fromHex(pkHex).multiply(e).add(sig.R)  ;//;new BN(mod(mod(toScalar() * e) + sig.R)).toArrayLike(Buffer, \"le\");\n   return  left.equals(right);\n}\n\n\nexport const personalSign = (privateKey: Buffer, msgParams:string):SignEL =>{\n   const msgBuf = ethUtil.toBuffer(msgParams);\n   const msgHash = hashPersonalMessage(msgBuf);\n   const str = msgHash.toString(\"hex\");\n   return ecsign(str,privateKey)\n}\nexport const hashPersonalMessage = function (message: Buffer): Buffer {\n   const prefix = Buffer.from(`\\u0019EMIT Signed Message:\\n${message.length}`, 'utf-8')\n   return ethUtil.keccak(Buffer.concat([prefix, message]))\n}\n\n\nexport const recoverPersonalSignature = (sig:SignEL,msgHex:string): string =>{\n   return ecrecover(sig,msgHex)\n}\n"]}