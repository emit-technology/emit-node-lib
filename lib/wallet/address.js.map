{"version":3,"file":"address.js","sourceRoot":"","sources":["../../src/wallet/address.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ADDRESS_BYTES_LEN,\n  ADDRESS_BYTES_PREFIX,\n  ED_BASE,\n  EMIT_ADDR_BS_H0,\n  EMIT_ADDR_BS_H1,\n} from \"./serial\";\nimport { blake2b, toScalar } from \"./sign\";\nconst bs58 = require(\"bs58\");\n\nexport function getPublicKeyBs58(privateKey: Buffer): string {\n  const pk = privateKey.slice(0, 32);\n\n  const pb = ED_BASE.multiply(toScalar(pk));\n  // const pubKey = Buffer.from(pb.toRistrettoBytes());\n  const pubKey = pb.toRawBytes();\n\n  const prefix = Buffer.from(ADDRESS_BYTES_PREFIX, \"hex\");\n  const h0 = blake2b(EMIT_ADDR_BS_H0, Buffer.concat([prefix, pubKey]));\n  const h0_r = Buffer.alloc(32, 0);\n  h0_r.fill(h0, 0, h0.length > 32 ? 32 : h0.length);\n\n  const h1 = blake2b(EMIT_ADDR_BS_H1, Buffer.concat([h0_r, pubKey]));\n  const h1_r = Buffer.alloc(32, 0);\n  h1_r.fill(h1, 0, h1.length > 32 ? 32 : h1.length);\n\n  const r = Buffer.alloc(ADDRESS_BYTES_LEN, 0);\n  const w = Buffer.concat([prefix, pubKey, h1_r.slice(0, 3)]);\n  r.fill(w, 0, w.length > ADDRESS_BYTES_LEN ? ADDRESS_BYTES_LEN : w.length);\n  return bs58.encode(r);\n}\n\nexport function getPublicKey(privateKey: Buffer): Buffer {\n  const sk = toScalar(privateKey.slice(0, 32));\n  const pubKey = ED_BASE.multiply(sk).toRawBytes();\n  const buf = Buffer.alloc(32, 0);\n  buf.fill(pubKey, 0, pubKey.length);\n  return buf;\n}\n\nexport function fromAddressBytes(addr: string): Buffer {\n  const data: Buffer = bs58.decode(addr);\n  if (data.length != ADDRESS_BYTES_LEN) {\n    throw new Error(\"the address bytes len != 36\");\n  }\n  if (data[0] != 0x1e) {\n    throw new Error(\"the address prefix is invalid\");\n  }\n  const h0 = blake2b(EMIT_ADDR_BS_H0, data.slice(0, 33));\n  const h0_r = h0.slice(0, 32);\n  const h1 = blake2b(EMIT_ADDR_BS_H1, Buffer.concat([h0_r, data.slice(1, 33)]));\n  const h1_r = h1.slice(0, 32);\n  if (data.slice(33).toString(\"hex\") != h1_r.slice(0, 3).toString(\"hex\")) {\n    throw new Error(\"the address bytes sum-check failed\");\n  }\n  return data.slice(1, 33);\n}\n"]}